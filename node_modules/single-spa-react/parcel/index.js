(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define('Parcel', ['exports', 'react', '../lib/single-spa-react.js'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('react'), require('../lib/single-spa-react.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.React, global.singleSpaReact);
    global.Parcel = mod.exports;
  }
})(this, function (exports, _react, _singleSpaReact) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react2 = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Parcel = function (_React$Component) {
    _inherits(Parcel, _React$Component);

    function Parcel(props) {
      _classCallCheck(this, Parcel);

      var _this = _possibleConstructorReturn(this, (Parcel.__proto__ || Object.getPrototypeOf(Parcel)).call(this, props));

      _this.handleRef = function (el) {
        _this.el = el;
      };

      _this.addThingToDo = function (action, thing) {
        if (_this.state.hasError && action !== 'unmount') {
          // In an error state, we don't do anything anymore except for unmounting
          return;
        }

        _this.nextThingToDo = (_this.nextThingToDo || Promise.resolve()).then(function () {
          if (_this.unmounted && action !== 'unmount') {
            // Never do anything once the react component unmounts
            return;
          }

          return thing.apply(undefined, arguments);
        }).catch(function (err) {
          _this.nextThingToDo = Promise.resolve(); // reset so we don't .then() the bad promise again
          _this.setState({ hasError: true });

          if (err && err.message) {
            err.message = 'During \'' + action + '\', parcel threw an error: ' + err.message;
          }

          if (_this.props.handleError) {
            _this.props.handleError(err);
          } else {
            setTimeout(function () {
              throw err;
            });
          }

          // No more things to do should be done -- the parcel is in an error state
          throw err;
        });
      };

      _this.getParcelProps = function () {
        var parcelProps = Object.assign({}, _this.props);

        delete parcelProps.mountParcel;
        delete parcelProps.config;
        delete parcelProps.wrapWith;
        delete parcelProps.appendTo;
        delete parcelProps.handleError;
        delete parcelProps.parcelDidMount;

        return parcelProps;
      };

      _this.state = {
        hasError: false
      };

      if (!props.config) {
        throw new Error('single-spa-react\'s Parcel component requires the \'config\' prop to either be a parcel config or a loading function that returns a promise. See https://github.com/CanopyTax/single-spa-react');
      }
      return _this;
    }

    _createClass(Parcel, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        this.addThingToDo('mount', function () {
          var mountParcel = _this2.props.mountParcel || _this2.mountParcel;
          if (!mountParcel) {
            throw new Error('\n\t\t\t\t  <Parcel /> was not passed a mountParcel prop, nor is it rendered where mountParcel is within the React context.\n\t\t\t\t  If you are using <Parcel /> within a module that is not a single-spa application, you will need to import mountRootParcel from single-spa and pass it into <Parcel /> as a mountParcel prop\t\n\t\t\t\t');
          }
          var domElement = void 0;
          if (_this2.el) {
            domElement = _this2.el;
          } else {
            _this2.createdDomElement = domElement = document.createElement(_this2.props.wrapWith);
            _this2.props.appendTo.appendChild(domElement);
          }
          _this2.parcel = mountParcel(_this2.props.config, _extends({ domElement: domElement }, _this2.getParcelProps()));
          _this2.parcel.mountPromise.then(_this2.props.parcelDidMount);
          return _this2.parcel.mountPromise;
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var _this3 = this;

        this.addThingToDo('update', function () {
          if (_this3.parcel && _this3.parcel.update) {
            return _this3.parcel.update(_this3.getParcelProps());
          }
        });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var _this4 = this;

        this.addThingToDo('unmount', function () {
          if (_this4.parcel && _this4.parcel.getStatus() === "MOUNTED") {
            return _this4.parcel.unmount();
          }
        });

        if (this.createdDomElement) {
          this.createdDomElement.parentNode.removeChild(this.createdDomElement);
        }

        this.unmounted = true;
      }
    }, {
      key: 'render',
      value: function render() {
        var _this5 = this;

        if (this.props.appendTo) {
          if (_singleSpaReact.SingleSpaContext && _singleSpaReact.SingleSpaContext.Consumer) {
            return _react2.default.createElement(
              _singleSpaReact.SingleSpaContext.Consumer,
              null,
              function (context) {
                _this5.mountParcel = context ? context.mountParcel : null;

                return null;
              }
            );
          } else {
            return null;
          }
        } else {
          var children = _singleSpaReact.SingleSpaContext && _singleSpaReact.SingleSpaContext.Consumer ? _react2.default.createElement(
            _singleSpaReact.SingleSpaContext.Consumer,
            null,
            function (context) {
              _this5.mountParcel = context ? context.mountParcel : null;

              return null;
            }
          ) : undefined;

          return _react2.default.createElement(this.props.wrapWith, { ref: this.handleRef }, children);
        }
      }
    }]);

    return Parcel;
  }(_react2.default.Component);

  Parcel.defaultProps = {
    wrapWith: 'div',
    parcelDidMount: function parcelDidMount() {}
  };
  exports.default = Parcel;
});

//# sourceMappingURL=index.js.map