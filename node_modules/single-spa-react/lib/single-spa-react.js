(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['exports'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.singleSpaReact = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = singleSpaReact;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _defaultOpts;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  /* We don't import parcel.component.js from this file intentionally. See comment
   * in that file for why
   */

  // React context that gives any react component the single-spa props
  var SingleSpaContext = exports.SingleSpaContext = null;

  var defaultOpts = (_defaultOpts = {
    // required opts
    React: null,
    ReactDOM: null,
    rootComponent: null,
    loadRootComponent: null,
    domElementGetter: null,
    suppressComponentDidCatchWarning: false

  }, _defineProperty(_defaultOpts, 'domElementGetter', null), _defineProperty(_defaultOpts, 'parcelCanUpdate', true), _defaultOpts);

  function singleSpaReact(userOpts) {
    if ((typeof userOpts === 'undefined' ? 'undefined' : _typeof(userOpts)) !== 'object') {
      throw new Error('single-spa-react requires a configuration object');
    }

    var opts = _extends({}, defaultOpts, userOpts);

    if (!opts.React) {
      throw new Error('single-spa-react must be passed opts.React');
    }

    if (!opts.ReactDOM) {
      throw new Error('single-spa-react must be passed opts.ReactDOM');
    }

    if (!opts.rootComponent && !opts.loadRootComponent) {
      throw new Error('single-spa-react must be passed opts.rootComponent or opts.loadRootComponent');
    }

    if (!SingleSpaContext && opts.React.createContext) {
      exports.SingleSpaContext = SingleSpaContext = opts.React.createContext();
    }

    var lifecycles = {
      bootstrap: bootstrap.bind(null, opts),
      mount: mount.bind(null, opts),
      unmount: unmount.bind(null, opts)
    };

    if (opts.parcelCanUpdate) {
      lifecycles.update = update.bind(null, opts);
    }

    return lifecycles;
  }

  function bootstrap(opts, props) {
    if (opts.rootComponent) {
      // This is a class or stateless function component
      return Promise.resolve();
    } else {
      // They passed a promise that resolves with the react component. Wait for it to resolve before mounting
      return opts.loadRootComponent().then(function (resolvedComponent) {
        opts.rootComponent = resolvedComponent;
      });
    }
  }

  function mount(opts, props) {
    return new Promise(function (resolve, reject) {

      if (!opts.rootComponent.prototype.componentDidCatch && !opts.suppressComponentDidCatchWarning && atLeastReact16(opts.React)) {
        console.warn('single-spa-react: ' + (props.name || props.appName || props.childAppName) + '\'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire single-spa application.');
      }

      var domElementGetter = chooseDomElementGetter(opts, props);

      if (!domElementGetter) {
        throw new Error('Cannot mount react application \'' + (props.appName || props.name) + '\' without a domElementGetter provided in either opts or props');
      }

      var whenFinished = function whenFinished() {
        resolve(this);
      };

      var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
      var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, { value: props }, rootComponentElement) : rootComponentElement;
      var domElement = getRootDomEl(domElementGetter);
      var renderedComponent = reactDomRender({ elementToRender: elementToRender, domElement: domElement, whenFinished: whenFinished, opts: opts });
      opts.domElement = domElement;
    });
  }

  function unmount(opts, props) {
    return Promise.resolve().then(function () {
      opts.ReactDOM.unmountComponentAtNode(opts.domElement);
    });
  }

  function update(opts, props) {
    return new Promise(function (resolve, reject) {
      var whenFinished = function whenFinished() {
        resolve(this);
      };

      var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
      var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, { value: props }, rootComponentElement) : rootComponentElement;
      var renderedComponent = reactDomRender({ elementToRender: elementToRender, domElement: opts.domElement, whenFinished: whenFinished, opts: opts });
    });
  }

  function getRootDomEl(domElementGetter) {
    var el = domElementGetter();
    if (!el) {
      throw new Error('single-spa-react: domElementGetter function did not return a valid dom element');
    }

    return el;
  }

  function atLeastReact16(React) {
    if (React && typeof React.version === 'string' && React.version.indexOf('.') >= 0) {
      var majorVersionString = React.version.slice(0, React.version.indexOf('.'));
      try {
        return Number(majorVersionString) >= 16;
      } catch (err) {
        return false;
      }
    } else {
      return false;
    }
  }

  function chooseDomElementGetter(opts, props) {
    props = props && props.customProps ? props.customProps : props;
    if (props.domElement) {
      return function () {
        return props.domElement;
      };
    } else if (props.domElementGetter) {
      return props.domElementGetter;
    } else {
      return opts.domElementGetter;
    }
  }

  function reactDomRender(_ref) {
    var opts = _ref.opts,
        elementToRender = _ref.elementToRender,
        domElement = _ref.domElement,
        whenFinished = _ref.whenFinished;

    if (opts.renderType === 'createRoot') {
      return opts.ReactDOM.createRoot(domElement).render(elementToRender, whenFinished);
    }

    if (opts.renderType === 'hydrate') {
      return opts.ReactDOM.hydrate(elementToRender, domElement, whenFinished);
    }

    // default to this if 'renderType' is null or doesn't match the other options
    return opts.ReactDOM.render(elementToRender, domElement, whenFinished);
  }
});

//# sourceMappingURL=single-spa-react.js.map